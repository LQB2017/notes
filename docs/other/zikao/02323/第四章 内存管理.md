## 第一节 存储器的层次结构
### 存储器的层次结构
存储器的层次结构是一个金字塔形的结构，从上到下依次是：
1. 寄存器（Register）
2. 高速缓存（Cache）
3. 主存储器（Main Memory）
4. 外存储器（Secondary Storage）
### 局部性原理
局部性原理是指程序在执行过程中的访问呈现局部性特征，主要包括时间局部性和空间局部性。这种特性是高速缓存存储器的设计依据。
1. 时间局部性
- 程序中的某条指令一旦执行，不久后该指令可能再次执行
- 某个数据被访问过，不久后该数据可能再次被访问
2. 空间局部性
- 一旦程序访问了某个存储单元，不久后其附近的存储单元也可能被访问
## 第二节 程序的链接和装入
### 程序的链接
程序的链接是将多个独立的目标模块组合成一个完整的可执行程序的过程。主要包括以下内容：
1. 链接的方式
   - 静态链接：在程序运行前完成链接
   - 动态链接：在程序运行时进行链接
### 程序的装入
程序的装入是指将程序和数据装入内存的过程。主要包括以下内容：
1. 装入的方式
   - 绝对装入：程序在编译或汇编时就指定了绝对地址
   - 可重定位装入：程序装入时，对地址进行重定位
   - 动态运行时装入：程序运行时，动态地装入所需的模块
## 第三节 连续分配存储管理方式
### 单一连续分配
单一连续分配是最简单的内存分配方式，内存被分为系统区和用户区两个连续区域。
### 固定分区分配
固定分区分配是一种早期的内存管理方式，内存被分为若干个固定大小的分区。
1. 划分分区方法
- 分区大小相等:将用户内存空间分为大小相等的若干分区
- 分区大小不等:将用户内存空间分为若干个大小不等的分区
2. 支持固定分区分配的数据结构
- 分区编号
- 分区大小
- 分区起始地址
- 分区状态:0表示空闲，1表示已分配
3. 固定分区分配的过程
- 根据程序的大小，选择一个空闲分区进行分配，并修改分区状态为已分配
4. 固定分区的回收
- 回收分区后，修改分区状态为空闲
### 动态分区分配
动态分区分配是一种更灵活的内存管理方式，根据进程的实际需要动态地分配内存空间。
1. 动态分区分配原理
- 系统初始化时只有一个空闲分区,当有进程申请内存时，根据进程的大小，从空闲分区表中查找第一个满足需求的空闲分区
2. 动态分区分配中的数据结构
- 空闲分区表
  - 分区编号
  - 分区大小
  - 分区起始地址
- 空闲分区链
  - 分区大小
  - 分区起始地址
  - 下一个空闲分区的地址
  - 上一个空闲分区的地址
3. 动态分区分配算法
- 首次适应算法（First Fit）：从内存起始位置查找第一个满足需求的空闲分区
- 循环首次适应算法（Next Fit）：从上次查找结束的位置开始查找
- 最佳适应算法（Best Fit）：查找最小的能满足需求的空闲分区
- 最坏适应算法（Worst Fit）：查找最大的空闲分区
4. 动态分区分配的过程
- 当有进程申请内存时，根据进程的大小，从空闲分区表或空闲分区链中查找(可以使用不同分配算法)满足需求的空闲分区
- 如果找到空闲分区，则将进程装入该分区，并修改空闲分区表或空闲分区链中的分区状态为已分配
- 如果找不到空闲分区，则进行内存扩充
5. 动态分区的回收
- 释放分区后，将该分区加入空闲分区表或空闲分区链中，并修改分区状态为空闲
## 第四节 基本分页存储管理方式
### 分页存储管理的基本原理
1. 基本概念
- 页:内存被划分为大小相等的若干个页
- 页框:内存中实际分配的内存块
- 分页存储:将用户程序的地址空间划分为若干个页，并将页存储在页框中
## 第五节 基于分页的虚拟存储系统
## 第六节 分段存储管理
## 第七节 Liunx的伙伴系统